# [2517] 달리기


# 문제
KOI 장거리 달리기 대회가 진행되어 모든 선수가 반환점을 넘었다. 각 선수의 입장에서 자기보다 앞에 달리고 있는 선수들 중 평소 실력이 자기보다 좋은 선수를 남은 거리 동안 앞지르는 것은 불가능하다. 반대로, 평소 실력이 자기보다 좋지 않은 선수가 앞에 달리고 있으면 남은 거리 동안 앞지르는 것이 가능하다. 이러한 가정 하에서 각 선수는 자신이 앞으로 얻을 수 있는 최선의 등수를 알 수 있다.

각 선수의 평소 실력은 정수로 주어지는데 더 큰 값이 더 좋은 실력을 의미한다. 현재 달리고 있는 선수를 앞에서 부터 표시했을 때 평소 실력이 각각 2, 8, 10, 7, 1, 9, 4, 15라고 하면 각 선수가 얻을 수 있는 최선의 등수는 (같은 순서로) 각각 1, 1, 1, 3, 5, 2, 5, 1이 된다. 예를 들어, 4번째로 달리고 있는 평소 실력이 7인 선수는 그 앞에서 달리고 있는 선수들 중 평소 실력이 2인 선수만 앞지르는 것이 가능하고 평소실력이 8과 10인 선수들은 앞지르는 것이 불가능하므로, 최선의 등수는 3등이 된다.

선수들의 평소 실력을 현재 달리고 있는 순서대로 입력 받아서 각 선수의 최선의 등수를 계산하는 프로그램을 작성하시오.
# 입력
첫째 줄에는 선수의 수를 의미하는 정수 N이 주어진다. N은 3 이상 500,000 이하이다. 이후 N개의 줄에는 정수가 한 줄에 하나씩 주어진다. 이 값들은 각 선수들의 평소 실력을 앞에서 달리고 있는 선수부터 제시한 것이다. 각 정수는 1 이상 1,000,000,000 이하이다. 단, 참가한 선수들의 평소 실력은 모두 다르다.
# 출력
각 선수의 최선의 등수를 나타내는 정수 N개를 입력에 주어진 선수 순서와 동일한 순서로 한 줄에 하나씩 출력한다.


# 예제 입력 1
```python
8
2
8
10
7
1
9
4
15
```  

# 예제 출력 1
```python1
1
1
1
3
5
2
5
1
```

# 풀이
<br>
문제를 처음봤을때 어떻게 풀어야할지 감이 안와서 다른사람의 아이디어를 확인후 문제를 풀었다. <br>

문제의 핵심 아이디어는 좌표압축과 세그먼트 트리였다. 일단 달리고있을때 내앞에 나보다 잠재력이 낮은사람의 수를 현재 내등수에서 빼줬을때 나오는 값이 내 예상 등수이다.
이때 구간합을 구하기 위해서 세그먼트 트리를 접근하였고 이때 세그먼트 트리의 원소의 수가 10억이 넘어갈경우 메모리 초과가 날수있기 때문에 좌표압축을 진행해 줬다.

그리고 세그먼트 트리에서 input() , update() , sum()의 3가지 과정으로 나누어 풀어주었다. input()은 자기의 잠재력에 해당하는 위치에 1을 넣어주고
update()는 세그먼트 트리에서 자기의 부모노드로 계속올라가면서 +1을 해주었다. 그리고 이제 sum은 맨처음 부터 자기앞까지의 능력치가 자기보다 낮은 사람들을 count해 return해주었다.



